# Rust
> Rust 는 강한 정적 타입 시스템을 가진다. 하지만 타입 추론(type inference)도 수행한다.<br>
> 정적 타입(statically typed)언어는 모든 변수의 타입이 컴파일 시점에 반드시 정해져 있어야 한다.

# Rust 명령어
>`cargo new 프로젝트명` 새 프로젝트 생성<br>
`cargo build 프로젝트` 빌드(디폴트는 디버그 빌드), Cargo.lock 과 target/debug 디렉터리 생성<br>
`cargo run` 한번에 프로젝트 빌드 및 실행(실행파일 생성)<br>
`cargo check` 컴파일 수행<br>
`cargo build --release` 릴리스 빌드 생성(target/release 에 실행파일 생성)<br>
`cargo update` Cargo.lock 파일을 무시하고 Cargo.toml 에 버전 확인후 해당 버전을 Cargo.lock 에 기록<br><br>
둘 이상의 실행 가능한 바이너리를 만들 경우, src 디렉터리 내부에 bin 디렉터리 내부에 소스코드를 저장해야한다<br>
그리고 cargo run 명령에 --bin 옵션을 사용하거나 Cargo.toml 에 기본 실행을 지정해야 한다<br>

## 크레이트(crate)
>Rust 코드 파일들의 모음<br>
Rust 의 "패키지" 또는 "모듈 단위 프로그램" 이자, 컴파일러가 빌드할 수 있는 최소 단위<br>
외부 크레이트 == 라이브러리

## 트레이트(trait)
>타입이 어떤 "행동"을 해야하는지 정의한 약속(규약)<br>
Java 의 인터페이스와 비슷함

## 정수형
>i32 는 32bit 정수형(기본값)<br>
u32 는 부호 없는 32bit 정수형<br>
i64 는 64bit 정수형

## 반복문
>`loop {내용}` 으로 반복문을 설정할 수 있다. 그리고 break; 를 이용해 탈출하거나 Err Result 타입을 반환할 경우 반복문을 종료한다.

## 변수
>Rust 의 변수는 기본적으로 불변(immutable)이다.<br>
변수명 앞에 `mut` 을 추가함으로써, 변수의 값을 바꿀수 있는 가변(mutability) 상태로 변경 가능하다<br>
mut 을 추가하는 것은 '미래에 코드를 읽는 이들에게, 코드의 다른 부분에서 이 변수의 값이 변할 것이라는 의도를 전달한다'

## 상수(constant)
>상수는 불변 변수와 비슷하지만, mut 와 함께 사용할 수 없다<br>
항상 불변 상태를 유지한다<br>
let 키워드 대신 const 키워드로 선언하되, 값 타입을 반드시 명시해야 한다.<br>
상수는 전역 스코프를 포함한 어떤 스코프에서도 선언이 가능하다.<br>
반드시 상수 표현식으로만 설정될 수 있어야 하며, 런타임에서만 계산될 수 있는 결과값으로 사용하면 안된다.<br>
상수는 대문자 및 단어사이에 밑줄(_)을 사용하는게 관례이다.<br>
하드코딩 값에 상수를 사용한다

## 섀도잉
> 새 변수를 이전 변수명과 같은 이름으로 선언 할 수 있다. 이때, 첫 번째 변수가 두 번쨰 변수에 의해 가려졌다(shadowed)고 표현한다.<br>
> 해당 변수의 이름을 사용할 때, 컴파일러가 두 번째 변수를 보게 될 것이라는 의미이다.<br>
> 사실상 두 번째 변수는 첫 번째 변수를 가려서, 스스로를 다시 가리거나 스코프가 끝날 때까지 변수명의 사용을 가져가버린다.<br><br>
> mut 은 같은 메모리 공간을 사용하면서 값을 바꿈(변수 자체는 동일, 내부 값만 변경, 타입 변경 불가)<br>
> let 은 새 메모리 주소를 할당 하므로 이름만 같고 이전 변수와는 완전히 다른 변수이다.(타입 변경 가능)

## 데이터 타입(스칼라 타입 / 복합 타입)
> 스칼라(scalar) 타입은 하나의 값을 표현한다. 정수, 부동소수점 숫자, 불리언, 문자가 포함된다.

## 정수형(integer)
> 정수형은 소수점이 없는 숫자를 의미한다.<br>
> 부호가 있으면 i, 부호가 없으면 u 로 시작하고 bit 를 붙여서 표현한다. 예) i8, u8, i32, u32 <br>
> cpu 가 한 번에 처리할 수 있는 메모리 주소 크기(arch)는 isize, usize 로 표현한다.<br>
> 부호 있는 숫자는 2의 보수 형태를 사용하여 저장된다.(-2^n-1) ~ 2^n-1 까지 저장 가능<br>
> 정수형 리터럴은 타입 접미사를 사용하여 타입을 지정할 수 있다. 예) 57u8 <br>
> 1_000 처럼 읽기 쉽게 하기 위해 언더바(_) 사용 가능<br>
> 각 진수별 예) 10진수 98_222 16진수는 0xff, 8진수는 0o77, 2진수는 0b1111_0000, 바이트(u8만) b'A' <br>
> 정수형의 기본 타입은 i32(32bit, 부호 있는 숫자)이다.<br>
> isize 나 usize 는 컬렉션 종류의 인덱스에 사용된다.<br>

## 부동소수점(floating-point)
> 부동소수점은 Rust 에서 소수점을 갖는 숫자를 의미한다.<br>
> 부동소수점 타입은 f32, f64로 각각 32bit, 64bit 크기를 갖습니다.<br>
> 기본 타입은 f64 이다.(현대 cpu 상 f32 와 비슷한 속도를 내면서 더 정밀하기 때문) <br>
> 모든 부동소수점 타입은 부호가 있다. <br>
> 부동소수점 숫자는 IEEE-754 표준을 따른다. f32 타입은 1배수 정밀도(single-precision)인 부동 소수점이고 f64는 2배수 정밀도(double-precision)이다.

## 수치 연산
> 정수 나눗셈은 가장 가까운 정수값으로 버림한다.

## 불리언(boolean)
> Rust 에서 불리언 타입은 true, false 두 값을 가진다.<br>
> 불리언값은 1byte 크기이다.<br>
> 불리언타입은 bool 로 명시된다.

## 문자
> char 는 가장 기본적인 알파벳 타입이다.<br>
> 문자열 리터럴은 큰따옴표 "" 사용<br>
> char 타입은 작은따옴표 '' 사용<br>
> char 타입은 4byte 이며 유니코드 스칼라값을 표현한다.<br>

## 복합 타입(compound type)
> 복합 타입은 여러 값을 하나의 타입으로 묶을 수 있다.<br>
> Rust 는 튜플(tuple), 배열(array) 두 가지 기본 복합 타입이 있다.

## 튜플(tuple)
> 튜플은 고정된 길이를 갖는다. 한번 선언되면 크기를 변경할 수 없다.<br>
> 괄호 안에 쉼표(,)로 구분하여 값들의 목록을 작성한다.<br>
> 튜플 내 각 위치는 타입을 갖고 서로 달라도 된다.<br>
> 예) let tup: (i32, f64, u8) = (500, 6.4, 1);<br>
> 아무 값도 없는 튜플은 유닛(unit)이라고 불린다. 이 값과 타입 타입은 모두 ()로 작성되고 빈 값이나 비어 있는 반환 타입을 나타낸다.<br>
> 표현식이 어떤 값도 반환하지 않는다면 암묵적으로 유닉 값을 반환하게 된다.

## 배열(array)
> 튜플과 달리 배열의 모든 요소는 모두 같은 타입이어야 한다.<br>
> Rust 의 배열은 고정된 길이를 가진다.<br>
> 대괄호 [요소1, 요소2, 요소3, ...] 안에 쉼표(,)로 구분한 값들을 나열해서 배열로 만들 수 있다. 예) let arr = [1, 2, 3, 4, 5];<br>
> 배열은 힙 보다는 스택에 데이터를 할당하거나 항상 고정된 요소 개수로 이뤄진 경우 배열이 유용하다.<br>
> 배열은 스택에 하당될 수 있는 계산 가능한 고정된 크기의 단일 메모리 뭉치이다.<br>
> 인덱스를 통해 배열 요소에 접근 할 수 있다.<br>

## 함수
> 함수 선언시 fn 키워드를 사용한다.<br>
> Rust 코드는 함수나 변수 이름을 스네크 케이스 방식을 사용한다.<br>
> 호출하는 쪽에서 볼 수 있는 스코프 범위 내 함수가 정의만 되어 있으면 된다.<br>

## 매개변수(parameter)
> 함수는 매개변수를 갖도록 정의될 수 있다. 그리고 매개변수는 함수 시그니쳐(function signature)의 일부인 특별한 변수이다.<br>
> 함수가 매개변수를 갖고 있으면 이 매개변수에 대한 구체적인 값을 전달할 수 있다. 여기서 이 구체적인 값을 인수(argument)라고 부르라고도 부른다.<br>
> Rust 의 함수 시그니쳐는 각 매개변수의 타입을 반드시 선언해야 한다. 또, 함수의 정의에 타입 명시를 강제하면 이 함수를 다른 코드에서 사용할 때, 의도한 타입을 컴파일러가 추측하지 않아도 되게 한다.<br>

## 구문(statement)과 표현식(expression)
> 구문은 어떤 동작은 수행하고 값을 반환하지 않는 명령이다.<br>
> 표현식은 결과값을 평가한다.<br>
> Rust 의 구문은 값을 반환하지 않으므로, x=y=6 같은 할당은 불가능하다.<br>
> 표현식은 구문의 일부이지만, 함수와 매크로를 호출하는 것은 표현식이다. 또, 중괄호로 만든 새 스코프 블록도 표현식이다.<br>
> 표현식은 종결을 나타내는 세미콜론(;)을 쓰지 않는다. 만약 표현식 끝에 세미콜론을 추가하면, 표현식이 아니라 구문으로 변경되므로 값을 반환하지 않는다.

## 반환값을 갖는 함수
> 함수는 호출한 코드에 값을 반환할 수 있다. 반환 값은 명명할 필요가 없지만, 그 값의 타입은 화살표(->) 뒤에 선언되어야 한다.<br>
> Rust 의 함수 반환값은 함수 본문의 마지막 표현식의 값과 동일하다.<br>
> return 키워드와 값을 지정하여 함수로부터 일찍 값을 반환할 수 있지만, 대부분의 함수는 암묵적으로 마지막 표현식값을 반환한다.<br>

