# 패캐지, 크레이트, 모듈

## 크레이트(crate)
> Rust 가 컴파일시 고려하는 가장 작은 코드 단위<br>

### 바이너리 크레이트(binary crate)
> 커맨드 라인 프로그램이나 서버처럼 실행 가능한 실행 파일로 컴파일 할 수 있는 프로그램<br>
> main 함수를 포함해야한다.

### 라이브러리 크레이트(library crate)
> main 함수를 가지고 있지 않고 실행 파일 형태로 컴파일 되지 않는다.<br>
> 여러 프로젝트에서 공용될 의도로 만들어진 기능들을 정의한다.<br>
> Rust 에서 크레이트는 대부분 라이브러리 크레이트를 의미한다.(일반적인 프로그래밍 개념에서 라이브러리와 혼용된다)<br>

### 크레이트 루트(crate root)
> Rust 컴파일러가 컴파일을 시작하는 소스 파일

### 패키지(package)
> 기능을 제공하는 하나 이상의 크레이트로 구성된 번들.<br>
> 패키지가 크레이트를 빌드하는 법은 Cargo.toml 파일에 포함되어 있다.<br>
> 패키지는 여러 바이너리 크레잍트가 원하는 만큼 포함될 수 있지만, 라이브러리 크레이트는 하나만 넣을 수 있다.<br>

> 카고는 패키지명과 같은 이름의 바이너리 크레이트는 src/main.rs 가 크레이트 루트라는 관례를 준수한다.<br>
> 마찬가지로, 패키지 디렉터리에 src/lib.rs 파일이 존재할 경우, 카고는 해당 패키지가 패키지명과 같은 이름의 라이브러리 크레이트를 포함하고 있다고 판단한다.<br>
> 그리고 그 라이브러리 크레이트의 루트는 scr/lib.rs 이다.<br>
> 카고는 라이브러리 또는 바이너리를 빌드할 때, 이 크레이트 루트 파일을 rustc 에 전달한다.<br>

> 일반적으로 프로젝트를 생성 하면, Cargo.toml 의 [package] 에 바이너리 크레이트인 src/main.rs 가 추가된다.<br>
> 만약 어떤 패키지가 src/main.rs 와 src/lib.rs 를 가지고 있다면, 해당 패키지는 패키지와 같은 이름의 바이너리(기본 바이너리), 라이브러리 크레이트(기본 라이브러리)를 포함하게 된다.<br>
> 즉, Cargo 가 자동으로 두 개의 크레이트를 인식한다.<br>
> src/bin 디렉터리 내에 파일을 배치하면(추가 바이너리들), 각각의 파일이 바이너리 크레이트로 취급되어 패키지에 여러 바이너리 크레이트를 포함할 수 있다.

### 모듈
> 크레이트 루트 파일(바이너리 크레이트: src/main.rs 또는 라이브러리 크레이트: src/lib.rs)에 mod 모듈명; 이라는 코드로 모듈을 선언할 수 있다(mod 는 비공개(private) 모듈선언, pub mod 는 공개(public) 모듈선언)<br>
> 서브 모듈은 크레이트 루트가 아닌 다른 파일에서 선언할 수 있다.<br>
> 서브 도듈도 마찬가지로 mod 서브모듈명(또는 pub mod 서브모듈명)로 만들 수 있다.<br>
> use 키워드를 사용해 긴 경로의 반복을 줄이는 단축 경로를 만들 수 있다.<br>

> 크레이트 루트(src/main.rs 또는 src/lib.rs)는 모듈 트리(module tree)라고 불리는 크레이트 모듈 구조에서 최상위에 crate 라는 이름을 갖는 모듈로 형성된다.<br>
> 트리는 모듈이 서로 어떻게 중첩되는지 보여준다. 특히, 모듈 내부에 또 다른 모듈을 정의할 수 있다. 그리고 트리 구조이므로 모듈끼리 형제(sibling) 관계를 가질 수 있다.<br>
> 모듈 A가 모듈 B 안에 있으면, 모듈 A 는 모듈 B 의 자식(child)이고, 모듈 B 는 모듈 A 의 부모(parent)라고 한다.

## 경로
### 절대 경로(absolute path)
> 크레이트 루트로부터 시작되는 전체 경로이다. 외부 크레이트로 시작되는 경우, 해당 크레이트 이름으로 절대 경로가 시작되고 현재 크레이트로부터 코드는 crate 리터럴로 시작된다.<br>

### 상대 경로(relative path)
> 현재의 모듈을 시작점으로 하고 self, super 또는 현재 모듈 내 식별자를 사용한다.<br>


