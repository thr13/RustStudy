# 소유권(ownership)
> 일반적으로 프로그램은 작동하는 동안 컴퓨터의 메모리 사용 방법을 관리해야 한다.<br>
> 몇몇 언어들은 가비지 컬렉션으로 프로그램에서 더 이상 사용하지 않는 메모리를 정기적으로 찾거나, 프로그래머가 직접 명시적으로 메모리를 할당하고 해제하는 방식을 사용한다<br>
> Rust 는 위 두가지 방식이 아닌, 소유권이라는 시스템을 만들고 컴파일러가 컴파일 중에 검사할 여러 규칙을 정해 메모리를 관리하는 방식이다.<br>

## 스택 영역과 힙 영역
> 스택(stack)은 값이 들어온 순서대로 저장하고 역순으로 저장한다.(후입선출, LIFO) 그리고 스택에 데이터를 추가하는 행위를 푸시(PUSH), 스택에서 데이터를 제거하는 행위를 팝(POP)이라 한다.<br>
> 스택에 저장되는 데이터는 모두 명확하고 크기가 정해져 있어야 한다.<br>
> 컴파일 타임에 크기를 알 수 없거나, 크기가 변경될 수 있는 데이터는 스택 대신 힙에 저장되야 한다<br><br>
> 힙(heap)은 스택보다 복잡하다. 우리가 데이터를 힙에 넣을 때, 먼저 저장할 공간이 있는지 운영체제에 물어본다.<br>
> 메모리 할당자는 커다란 힙 영역 안에서 빈 지점을 찾고, 이 지점을 사용 중 이라고 표시한 뒤, 해당 지점을 가리키는 포인터(pointer)를 우리에게 반환한다.<br>
> 위 과정을 힙 공간 할당(allocating on the heap) 줄여서 할당(allocation)이라고 한다. 반면 스택에 값을 푸시하는 것은 할당이라 부르지 않는다.<br>
> 포인터는 크기가 정해져 있어, 스택에 저장할 수 있으나 포인터가 가리키는 실제 데이터를 사용할때는 포인터를 **참조**해, 해당 포인터가 가리키는 위치로 이동하는 과정을 거쳐야 한다.<br><br>
> 스택 영역은 데이터에 접근하는 방식상 힙 영역보다 속도가 빠르다. 메모리 할당자가 새 데이터를 저장할 공간을 찾을 필요 없이 항상 스택의 가장 윗 부분에 데이터를 저장하면 되기 때문이다.(데이터가 서로 붙어있다)<br>
> 반면, 힙에 공간을 할당하는 작업은 좀 더 많은 자원을 요구한다. 메모리 할당자가 데이터를 저장하기 위한 충분한 공간을 먼저 찾고, 다음 할당을 위한 준비를 위해 예약을 수행해야 되기 때문이다.<br><br>
> 힙 영역은 포인터가 가리키는 곳을 찾아가는 과정을 거치므로 느리다. 현대 프로세서는 메모리 내부에 왔다 갔다 하는 작업이 적을수록 속도가 빨라지는데 힙 영역에 있는 데이터들은 서로 떨어져 있어 프로세서가 돌아다녀야 하기 때문에 느리다.<br><br>
> 함수 호출시, 호출한 함수에 넘겨준 값(또는 힙 영역의 데이터를 가리키는 포인터)과 해당 함수의 지역 변수들이 스택에 푸시된다. 그리고 이 데이터들은 함수가 종료될 때 스택에서 팝된다.<br>
> 코드에서 힙의 어떤 데이터를 사용하는지 추적하고 힙에서 중복된느 데이터를 최소화하며, 쓰지 않는 데이터를 힙에서 정리해 메모리 영역을 확보하는 등 작업은 모두 소유권과 관련되어 있다.
> 반대로 소유권을 한번 이해하면 스택, 힙 영역으로 고민할 일이 줄어들 것 이다.<br>
> 소유권의 주 목표는 힙 데이터의 관리이다.

## 소유권 규칙
> Rust 에서 각각의 값은 소유자(owner)가 정해져 있다.<br>
> 한 값의 소유자는 동시에 여러개로 존재할 수 없다.(하나의 데이터는 오직 한 변수만이 그 메모리를 책임질 수 있다.)<br>
> 소유자가 스코프 밖으로 벗어날 때, 값은 버려진다.(dropped)<br>
> 러스트는 변수가 스코프 밖으로 벗어날 때, drop 이라는 특별한 함수를 자동으로 호출한다. 이 함수는 개발자가 직접 메모리 해제 코드를 작성해 넣을 수 있다.<br>

## 이동(move)
> String 타입 변수는 스택에 포인터, 길이, 용량이 생성된다. 그리고 포인터는 힙 영역에 생성된 데이터를 가르킨다.<br>
> 문자열 변수를 다른 변수에 할당할 경우, 기존의 스택에 있던 포인터, 길이, 용량을 복사하고 기존 변수를 무효화시킨다. 이는 얕은 복사 개념과 다르다.<br>
> Rust 에서는 이렇게 스택 데이터를 복사한 다음, 기존 변수를 무효화 시키는 것을 이동(move)되었다고 표현한다. 다른말로 소유권이 이전되었다 라고 표현할 수 있다.<br>
> 만약 스택 데이터 뿐만 아니라 힙 데이터까지 깊은 복사를 원한다면 clone() 공용 메서드를 사용하면 된다.

## 스택에만 저장되는 데이터 복사
> 정수형과 같이 컴파일 타임에 크기가 고정되는 타입은 모두 스택에 저장된다.<br>
> Rust 에는 정수형 처럼 스택에 저장되는 타입에 붙여놓을(place) 수 있는 Copy 트레이트가 있다.<br>
> 만약, 어떤 타입에 이 Copy 트레이드가 구현되어 있다면, 이 타입의 변수는 사용되어도 이동하지 않고 자명하게 복사된다. 또, 대입 연산 후에도 사용할 수 있다.<br>
> 하지만 구현하려는 타입이나, 구현 타입 중 일부분에 Drop 트레이트가 구현된 경우 Copy 트레이트를 애너테이션(annotation)할 수 없다.<br>
> 즉, 스코프 밖으로 벗어났을 때 특정 동작이 요구되는 타입에 Copy 애너테이션을 추가하면 컴파일 에러가 발생한다.<br>
> 일반적으로 단순한 스칼라값의 묶음은 Copy 가능하고 할당이 필요하거나 리소스의 일종인 경우에는 Copy 가 불가능하다.<br><br>
> Copy 가능 타입: 모든 정수형 타입, bool 타입, 모든 부동소수점 타입, 문자 타입 char, Copy 가능한 타입으로만 구성된 튜플

## 소유권과 함수
> 함수로 값을 전달하는 메커니즘은 변수에 값을 대입할 때와 유사하다. 함수에 변수를 전달하면 대입 연산(=)과 마찬가지로 이동이나 복사가 일어나기 때문이다.<br>
> 즉, Copy 가능한 타입을 넘겨줄 경우 복사되고, Copy 불가능한 타입은 소유권을 넘겨줌과 동시에 원본은 더 이상 사용할 수 없다. 함수의 스코프 종료시 drop 이 호출된다<br>

## 참조(reference)와 대여(borrowing)
> 참조자(reference)는 해당 주소에 저장된 데이터가 접근할 수 있도록 해주는 주소값에 해당되는 포인터와 비슷하다.<br>
> 그 데이터는 다른 변수가 소유하고 있다. 포인터와 다르게 참조자는 살아 있는 동안 특정 타입에 대한 유효한 값을 가르키는 것을 보장해준다.<br>
> 앰퍼샌드(&) 기호가 참조자를 나타내며, 어떤 값의 소유권을 가져오지 않고 해당 값을 참조할 수 있도록 해준다. 참조자는 함수 시그니쳐에 &을 붙여서 사용한다<br>
> 참조자 대여의 스코프는 사용된 시점까지 이다.
```
let s1 = String::from("hello");
let len = calculate_length(&s1); // s1 값을 참조하지만 해당 값을 소유하지 않는 참조자를 생성한다. 값을 소유하지 않으므로 이 참조자가 가리킨 값은 참조자가 사용되지 않을 때까지 버려지지 않는다.
```
> 함수가 실제값 대신 참조자를 매개변수로 쓴다면, 소유권이 없으므로 이 소유권을 돌려주기 위한 값 반환도 필요 없어진다.<br>
> 참조자를 만드는 행위를 대여(borrowing)라고 한다.<br>
> 변수의 기본값이 불변성을 지니듯 기본적으로 참조자도 마찬가지로 참조하는 것을 수정할 순 없다.

## 가변 참조자(mutable reference)
```
fn main () {
let mut s = String::from("hello);
change(&mut s);
...
}
fn change(some_string: &mut String) {...}
```
> 가변 변수를 생성후 함수를 호출하는 곳에서 가변 참조자를 생성하고 가변 참조자를 전달 받도록 함수 시그니쳐에 &mut 타입으로 수정할 경우, 이 함수는 빌린 값을 수정할 수 있다.<br>
> 그러나 어떤 값에 대한 가변 참조자가 있다면, 그 값에 대한 참조자는 더 이상 만들 수 없다. 즉, 가변 변수에 두 개 이상의 가변 참조자 생성은 불가능하다.
> Rust 는 데이터 경합(data race)을 방지한다.<br>
> 데이터 경합은, 둘 이상의 포인터가 동시에 같은 데이터에 접근하거나, 포인터 중 하나 이상이 데이터에 쓰기 작업을 수행하거나, 데이터 접근 동기화 메커니즘이 없는 경합 조건을 의미한다.<br>
> 만약 가변 참조자를 여러개 만들고자 할 경우, 중괄호 {} 내부에 새 스코프를 만들어 가변 참조자가 동시에 존재하는 상황을 회피하는 방법이 있다.<br><br>
> 어떤 값에 대한 불변 참조자가 있는 동안 같은 값의 가변 참조자를 만드는 것 또한 불가능하다.<br>
> 참조자는 정의된 지점부터 시작하여 해당 참조자가 마지막으로 사용된 부분까지 유효하다.
```
let mut s = String::from("hello");
let r1=&s;
let r2=&s;
println!("{} and {}", r1, r2); // 이 라인 이후로 변수 r1 과 r2는 사용되지 않는다.
let r3 = &mut s; // 참조자가 사용되었으므로 이 라인은 문제 없음
```

